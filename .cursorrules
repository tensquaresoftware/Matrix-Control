===============================================================================
# INSTRUCTIONS PERSONNELLES POUR L'AGENT IA CURSOR
===============================================================================
- Auteur : Guillaume DUPONT
- Organisation : Ten Square Software
- Contexte : Développement de plugins VST/AU avec JUCE
- Version : 1.0.0
- Dernière mise à jour : 2026-01-20


===============================================================================
## COMMUNICATION
===============================================================================

[Interactions avec moi]
- Je m'appelle Guillaume, tu peux m'appeler par mon prénom
- Utilise toujours le tutoiement dans tous nos échanges
- Réponds-moi exclusivement en français dans nos conversations
- Sois franc, honnête et factuel, même si cela implique de me contredire
- Priorité absolue : m'aider à trouver la solution la plus pertinente !

[Structure des réponses]
- Structure claire et didactique
- Objectif : m'aider à progresser
- Garantir pérennité et maintenabilité du code généré
- Solutions optimales et conformes aux standards professionnels


===============================================================================
## ENVIRONNEMENT DE DÉVELOPPEMENT
===============================================================================

[Système & Outils]
- Plateforme : MacBook Pro M5 avec macOS Tahoe
- IDE : Cursor (avec abonnement mensuel Agent IA)
- Compilateur : Xcode 26
- Build system : CMake
- Framework audio : JUCE 8.0.12

[Référence JUCE]
- Installation JUCE sur mon Mac : /Applications/JUCE
- Documentation officielle : https://docs.juce.com
- Modules : /Applications/JUCE/modules/
- CMake : /Applications/JUCE/CMake/

[Vérification du code généré]
- Réfère-toi systématiquement à la documentation JUCE la plus à jour
- Vérifie que chaque API, classe et méthode existe dans JUCE 8
- Évite toute syntaxe obsolète (JUCE 7, JUCE 6, etc.)
- Signale explicitement si tu n'es pas certain d'une API


===============================================================================
## STANDARDS C++ & QUALITÉ
===============================================================================

[Généralités C++]
- Standard : C++17 minimum, compatible Xcode 26
- Langage du code source : Anglais uniquement
  * Noms de variables, fonctions, classes
  * Tous les commentaires de code
  * Pas d'accents, pas de français dans le code

[Git]
- Git Commits : Summary/Description en anglais uniquement
- Lors de la création d'un tag Git annoté, utiliser le format suivant :
  * Une phrase de description principale (titre du tag)
  * Une petite liste à puces des points les plus importants qui ont été retravaillés dans le code
- Exemple de format :
  ```
  Refactor Slider class and improve focus management

  - Refactor Slider: simplify drawing code by removing unnecessary constants and helper methods
  - Use reduced() for bounds calculations directly in paint() method
  - Improve focus management: add ability to remove focus by clicking on background
  ```
- Ne pas inclure les détails d'implémentation ni les widgets de test temporaires
- Se concentrer sur les améliorations architecturales et les changements significatifs du code

[Conventions de nommage]
- Variables & Méthodes : lowerCamelCase
  * Exemples : audioBuffer, processMidiEvents(), getSampleRate()
- Variables et constantes publiques : pas de préfixe ni suffixe
  * Exemples : pluginFactory, kMaxBufferSize
- Variables et constantes privées : suffixe underscore (Google Style)
  * Exemples : apvts_, kWidth_
- Classes : PascalCase
  * Exemples : PluginProcessor, PluginEditor, AudioAnalyzer
- Enums : PascalCase pour le type, préfixe `k` pour les valeurs
  * Exemples : `enum class ParameterType { kDco, kEnv, kLfo };`
- Namespaces : PascalCase
  * Exemples : `namespace Core { }`, `namespace GUI { }`
- Éviter les underscore_case, sauf cas très particulier

[Magic Numbers - INTERDITS]
- Ne JAMAIS utiliser de magic numbers dans le code !
- Toujours définir des constantes explicites avec des noms significatifs
- Exemples à éviter :
  * `if (value == -1)` → utiliser quelque chose comme `if (value == kNoSysExId)`
  * `for (int i = 0; i < 10; ++i)` → utiliser `for (int i = 0; i < kModulationBusCount; ++i)`
  * `return nullptr;` → OK (nullptr est explicite, pas un magic number)
- Les seules exceptions acceptables :
  * Valeurs littérales évidentes et auto-explicatives : `0`, `1`, `nullptr`, `true`, `false`
  * Valeurs dans des tests unitaires où la valeur exacte est le sujet du test

[Organisation des includes]
1. Headers système C++ (ex : <vector>, <memory>, etc. puis sauter une ligne)
2. Headers JUCE (ex : <juce_core/juce_core.h>, etc. puis sauter une ligne)
3. Headers du projet (ex : "Core/PatchModel.h", etc. puis sauter une ligne)

[Chemins des includes]
- Utiliser des chemins relatifs à partir de la racine du projet (configuré dans CMake)
- Ne JAMAIS utiliser de chemins relatifs avec `../` multiples
- Format : `"GUI/Panels/MainComponent.h"` plutôt que `"../../../../../GUI/Panels/MainComponent.h"`
- Les chemins doivent être clairs, lisibles et maintenables
- Exemple correct : `#include "GUI/Widgets/Slider.h"`
- Exemple à éviter : `#include "../../../GUI/Widgets/Slider.h"`

[Include Guards]
- Toujours utiliser `#pragma once` en première ligne de chaque header
- Ne pas utiliser les anciens include guards (#ifndef/#define/#endif)
- Exemple : `#pragma once` en première ligne, avant tout autre code

[Forward Declarations]
- Utiliser des forward declarations dans les headers pour réduire les dépendances
- Inclure les headers complets uniquement dans les .cpp quand possible
- Exemple : `class MidiManager;` dans le header, puis `#include "MidiManager.h"` dans le .cpp

[Séparation .h/.cpp]
- Toujours séparer déclaration (.h) et définition (.cpp) sauf pour :
  * Templates (définitions dans le header)
  * Fonctions inline explicites (marquées `inline`)
  * Petites fonctions triviales (getters/setters simples)
- Préférer les méthodes inline dans le header uniquement si elles sont courtes (< 5 lignes)
- Exemple inline : `int getValue() const { return value_; }` dans le header
- Exemple séparé : déclaration dans .h, définition complète dans .cpp

[Organisation des classes]
- Regrouper les membres et méthodes logiquement dans les .h (ex: paires getter/setter)
- Variables membres (presque toujours privées) après les méthodes publiques/protégées
- Méthodes privées à la fin, après les variables membres
- Utiliser `JUCE_DECLARE_NON_COPYABLE` si la classe n'est pas copiable (dernier élément)
- Marquer `explicit` les constructeurs à un seul paramètre
- Dans les .cpp, regrouper les méthodes logiquement (appelées proches de leurs appelantes)
- Destructeurs virtuels si la classe est destinée à être héritée (polymorphisme)
- Règle des 3/5/0 : si on définit destructeur/copy/move, définir ou supprimer les autres explicitement
- Utiliser `= default` pour les constructeurs/destructeurs générés par défaut (plus explicite)
- Utiliser `= delete` pour désactiver explicitement copy/move/constructeur par défaut
- Exemple : `MyClass() = default;` ou `MyClass (const MyClass&) = delete;`

[Principes SOLID & Clean Code / Clean Architecture (Robert C. Martin / Uncle Bob)]
- Code lisible et compréhensible par un humain
- Noms TOUJOURS explicites (pas d'abréviations énigmatiques)
- Minimiser les commentaires : utiliser uniquement si nécessaire
- Refactoriser les blocs > 20 lignes en fonctions courtes aux noms explicites plutôt que d'ajouter des commentaires (qui peuvent devenir obsolètes)
- Fonctions courtes : 5-20 lignes idéalement
- Un seul niveau d'abstraction par fonction
- Une seule responsabilité (Single Responsibility)
- Pas d'effets cachés, pas d'état global modifié
- DRY (Don't Repeat Yourself)
- Respecter la Loi de Demeter
- Privilégier la délégation à l'héritage
- Exceptions > null pointers
- std::optional > null
- Traiter les erreurs au niveau approprié

[Gestion des Erreurs]
- Utiliser les exceptions pour les erreurs exceptionnelles (pas pour le flux normal)
- Utiliser `std::optional` pour les valeurs optionnelles (éviter `nullptr`)
- Utiliser `std::expected` (C++23) ou des types Result pour les opérations pouvant échouer
- Ne jamais ignorer silencieusement les erreurs
- Logger les erreurs avec un contexte approprié
- Exemple : `std::optional<PatchModel> loadPatch (const juce::File& file);`

[RAII (Resource Acquisition Is Initialization)]
- Toujours acquérir les ressources dans les constructeurs
- Toujours libérer les ressources dans les destructeurs
- Utiliser les smart pointers pour la gestion automatique de la mémoire
- Les objets doivent toujours être dans un état valide
- Exemple : `std::unique_ptr<juce::MidiInput> midiInput_;` dans la classe, libéré automatiquement

[Smart Pointers]
- Préférer `unique_ptr` pour la propriété exclusive (ownership)
- Utiliser `shared_ptr` uniquement si nécessaire (propriété partagée)
- Utiliser `weak_ptr` pour casser les cycles de références
- Éviter les pointeurs bruts sauf pour observer (non-owning)
- Exemple : `std::unique_ptr<juce::MidiInput> midiInput_;` pour ownership, `MidiInput* input` pour observer

[Move Semantics]
- Utiliser `std::move()` pour transférer la propriété des objets lourds
- Préférer les constructeurs de move et opérateurs d'assignation de move
- Marquer `noexcept` quand approprié (optimisations, contraintes de move)
- Exemple : `void setData (juce::MemoryBlock&& data) { data_ = std::move (data); }`


===============================================================================
## FORMATAGE & STYLE JUCE
===============================================================================

[Formatage et espacement]
- Pas de caractères de tabulation ! Utiliser 4 espaces pour l'indentation
- Style Allman pour les accolades (accolade ouvrante sur nouvelle ligne) :
  ```cpp
  if (x == 0)        // Oui !
  {
      foobar();
      return "zero";
  }
  ```
- Toujours mettre un espace avant et après les opérateurs binaires : `x = 1 + y - 2 * z / 3;`
- L'opérateur `!` ne doit PAS avoir d'espace après : `if (!foo)` (style JUCE standard)
- L'opérateur `~` doit être précédé d'un espace, mais pas suivi
- Les opérateurs `++` et `--` n'ont pas d'espace entre l'opérateur et l'opérande : `++i`, `--j`
- Jamais d'espace avant une virgule, toujours un espace après : `foo (x, y);`
- Toujours un espace avant une parenthèse ouvrante contenant du texte : `foo (123);`
- Jamais d'espace avant une paire de parenthèses vides : `foo();`
- Pas d'espace avant un crochet ouvrant utilisé comme index de tableau : `foo[1]`
- Ligne vide avant `if`, `for`, `while`, `do` quand précédés d'une autre instruction
- Ligne vide après une accolade fermante `}` (sauf si la ligne suivante est juste une autre accolade fermante)
- Ne pas écrire les `if` sur une seule ligne... sauf pour des séries de `if` similaires alignés verticalement pour montrer un pattern :
  ```cpp
  if (x == 1) return "one";
  if (x == 2) return "two";
  if (x == 3) return "three";
  ```
- Oublier les accolades pour des instructions `if` trivialement simples d'une ligne
- Dans un `if-else` avec plusieurs branches, toutes les branches doivent être formatées de la même manière (toutes avec ou toutes sans accolades)
- Ne JAMAIS mettre un `else` après un `return` ! Utiliser plutôt :
  ```cpp
  if (foobar())
      return doSomething();
  doSomethingElse();  // Mieux !
  ```

[Déclarations de pointeurs et références]
- Toujours mettre un espace après le type, jamais avant : `SomeObject* myObject`, `SomeObject& myObject`
- Ne jamais déclarer plusieurs pointeurs/références du même type dans une seule déclaration
- Préférer les smart pointers ou typedef pour éviter les astérisques multiples

[Modificateur const]
- Mettre `const` avant le nom du type : `const Thing& t;` (pas `Thing const& t;`)
- Marquer les méthodes qui ne modifient pas l'état comme `const`
- Utiliser `const&` pour les paramètres en lecture seule
- Préférer `const_iterator` pour les itérations en lecture seule
- Les pointeurs const : `const Type*` (pointeur vers constante) vs `Type* const` (pointeur constant)

[Opérateurs et expressions multi-lignes]
- Quand on divise une expression contenant des opérateurs sur plusieurs lignes, chaque nouvelle ligne doit commencer par l'opérateur :
  ```cpp
  auto xyz = foo + bar
              + func (123)
              - def + 4321;
  ```
- Même principe pour l'opérateur point (méthodes chaînées) :
  ```cpp
  auto t = AffineTransform::translation (x, y)
                         .scaled (2.0f)
                         .rotated (0.5f);
  ```

[Lambdas]
- Style préféré :
  ```cpp
  auto myLambda = [] { return 123; };
  auto myLambda = [this, &x] (int z) -> float { return x + z; };
  auto longerLambda = [] (int x, int y) -> int
  {
      // ...multiple lines of stuff...
  };
  ```
- Préférer les captures explicites plutôt que `[=]` ou `[&]` (plus clair, évite captures accidentelles)
- Éviter les captures par valeur de gros objets (préférer `const&` ou `&` selon le cas)
- Exemple : `[this, &x, &y]` plutôt que `[&]` si on n'a besoin que de x et y

[Valeurs nulles et pointeurs]
- Ne JAMAIS utiliser `NULL`, `null`, ou `0` pour un pointeur nul ! Toujours utiliser `nullptr`
- Limiter la portée des pointeurs possibles nuls :
  ```cpp
  if (auto* f = getFoo())
      f->doSomething();
  // f est hors de portée ici, impossible d'utiliser un pointeur nul par erreur
  ```

[Passage de paramètres]
- Pour les petits objets POD, toujours passer par valeur, pas par référence
- Utiliser `const Foo&` seulement pour les objets complexes (Array, String, etc.)
- Classes JUCE à toujours passer par valeur : Point, Time, RelativeTime, Colour, Identifier, ModifierKeys, JustificationType, Range, PixelRGB, PixelARGB, Rectangle

[Opérateurs d'incrémentation]
- Toujours préférer pré-incrémentation à post-incrémentation : `for (int i = 0; i < 10; ++i)`

[Bibliothèque standard]
- Toujours préférer les versions std des fonctions plutôt que les équivalents C anciens
- Utiliser `std::abs`, `std::sqrt`, `std::sin`, `std::cos`, `std::pow` plutôt que `fabs`, `sqrtf`, `powf`, etc.

[Types]
- Ne jamais utiliser `unsigned` seul - toujours écrire `unsigned int`
- Utiliser les types JUCE : `int8`, `uint8`, `int16`, `uint16`, `int32`, `uint32`, `int64`, `uint64`
- Préférer les boucles range-based-for pour itérer sur les conteneurs plutôt que les boucles for brutes

[Auto]
- Style "almost-always-auto" mais éviter dans certains cas :
  - `auto x = 0;` → pas OK (pas évident que c'est un int signé)
  - `for (int i = 0; i < someNumber; ++i)` → OK (clair que c'est un int signé)
  - `bool someCondition = false;` → OK (plus clair que auto)
  - `auto someResult = thisReturnsABool();` → OK (utiliser auto si le RHS est une expression)

[Commentaires]
- Pour les commentaires courts d'une ou deux lignes, préférer `//` plutôt que `/* */`
- Toujours laisser un espace avant le texte dans un commentaire `//` : `// oui !` pas `//non !`
- Les noms de code doivent être auto-documentants (éviter les commentaires)
- Utiliser des commentaires uniquement pour expliquer le "pourquoi", pas le "comment"
- Pour les APIs publiques complexes, considérer Doxygen/Javadoc style comments

[Macros]
- Ne pas utiliser de macros ! Traiter les macros comme un dernier recours
- Ne jamais utiliser une macro juste pour contenir une valeur constante ou pour effectuer une fonction qui pourrait être faite comme une vraie fonction inline
- Si des macros sont utilisées, leur donner des noms qui ne vont pas entrer en conflit avec d'autres codes
- `#undef` les macros après les avoir utilisées, si possible

[Template]
- Les paramètres de template doivent suivre leur type sans espace : `vector<int>`
- Dans une déclaration template, laisser un espace avant le crochet ouvrant : `template <typename Type1, typename Type2>`

[Dépendances]
- Éviter les dépendances circulaires entre modules
- Utiliser des interfaces abstraites pour découpler (Dependency Inversion Principle)
- Respecter la hiérarchie des dépendances (GUI dépend de Core, pas l'inverse)

[Enums]
- Préférer `enum class` à `enum` pour la sécurité de type et éviter les collisions
- Nommer les enums au singulier (sauf collections) : `enum class ParameterType { kDco, kEnv, kLfo };`
- Préfixer les valeurs avec `k` : `ParameterType::kDco`
- Exemple : `enum class ClipboardType { kEmpty, kDco, kEnv, kLfo, kPatch };`

[Initialisation]
- Préférer l'initialisation uniforme `{}` : `int value {0};` plutôt que `int value = 0;`
- Initialiser les membres dans la liste d'initialisation du constructeur
- Ordre d'initialisation = ordre de déclaration des membres (pas l'ordre de la liste)
- Exemple : `MyClass (int x) : member1_ {x}, member2_ {0} {}`

[Namespaces]
- Utiliser des namespaces pour organiser le code par module
- Éviter les `using namespace` dans les headers (pollution globale)
- OK dans les .cpp pour simplifier : `using juce::String;`
- Exemple : `namespace Core { class MidiManager; }`

[Static Members]
- Préférer les fonctions libres statiques aux méthodes statiques quand possible
- Utiliser `static constexpr` pour les constantes de classe
- Exemple : `static constexpr int kMaxBufferSize {1024};`

[Constexpr]
- Utiliser `constexpr` pour les fonctions calculables à la compilation
- Utiliser `constexpr` pour les variables constantes calculables à la compilation
- Préférer `constexpr` à `const` pour les constantes calculables à la compilation
- `constexpr` implique `const`, mais permet l'évaluation à la compilation
- Exemple : `constexpr int calculateSize (int count) { return count * 4; }`
- Exemple : `constexpr int kBufferSize {calculateSize (256)};`

[Virtual Functions]
- Utiliser `override` explicitement (pas `virtual` dans les classes dérivées)
- Utiliser `final` pour empêcher la dérivation supplémentaire si approprié
- Préférer la composition à l'héritage (SOLID : favoriser la délégation)
- Exemple : `void paint (Graphics& g) override;`

[Assertions]
- Utiliser `jassert` (JUCE) ou `assert` pour les invariants de développement
- Ne pas utiliser d'assertions pour la gestion d'erreurs utilisateur (utiliser exceptions)
- Les assertions peuvent être désactivées en release : ne pas y mettre de logique critique
- Exemple : `jassert (bufferSize > 0);` pour vérifier un précondition

[Logging]
- Utiliser `juce::Logger` pour le logging structuré
- Niveaux appropriés : `DBG()`, `Logger::writeToLog()` pour debug, erreurs critiques
- Éviter le logging excessif dans les boucles critiques
- Logger avec contexte : inclure informations pertinentes (fichier, ligne, valeurs)


===============================================================================
## RÈGLES SPÉCIFIQUES JUCE
===============================================================================

[Nommage des classes du plugin]
- Classe du processeur : "PluginProcessor" (fichiers : PluginProcessor.h/.cpp)
- Classe de l'éditeur UI : "PluginEditor" (fichiers : PluginEditor.h/.cpp)

[APIs JUCE dépréciées - À ÉVITER]
- ~~getCurrentPlaybackSampleRate()~~ → getSampleRate()
- ~~setPlayConfigDetails()~~ → setBusesLayout()
- ~~Timer avec callbacks~~ → juce::HighResolutionTimer
- ~~AudioProcessorValueTreeState~~ → ValueTree moderne
- ~~Legacy parameter handling~~ → juce::AudioProcessorParameter

La liste est non exhaustive, prendre le temps de la compléter le cas échéant.

[Thread-Safety]
- Toujours considérer la thread-safety dans le code audio (`processBlock()` appelé depuis le thread audio)
- Utiliser `juce::MessageManager::callAsync()` pour appeler le thread GUI depuis d'autres threads
- Utiliser `juce::AbstractFifo` ou `juce::LockFreeFifo` pour la communication inter-threads (lock-free)
- Les listeners APVTS sont thread-safe, mais les mises à jour GUI doivent se faire depuis le thread message
- Ne JAMAIS appeler de méthodes GUI depuis le thread audio
- Exemple : `juce::MessageManager::callAsync ([this] { updateGUI(); });` depuis le thread audio

[Performance]
- Éviter les allocations mémoire dans `processBlock()` (thread audio)
- Utiliser des buffers pré-alloués
- Éviter les appels système dans les boucles critiques
- Profiler avant d'optimiser
- Préférer les algorithmes in-place quand possible
- Éviter les copies inutiles : utiliser `const&` ou move semantics

[Tests Unitaires]
- Écrire des tests pour les classes métier (pas pour les composants GUI)
- Utiliser un framework de test (ex: Catch2, Google Test)
- Un test = une responsabilité, nom explicite
- Tests isolés, pas de dépendances entre tests
- Exemple : `TEST_CASE ("SysExParser validates checksum correctly")`

[Complexité]
- Maintenir la complexité cyclomatique < 10 par fonction
- Si trop complexe, refactoriser en sous-fonctions
- Éviter > 5 paramètres : considérer un struct/class de paramètres
- Préférer les early returns pour réduire l'imbrication

===============================================================================
# FIN DE MES INSTRUCTIONS PERSONNELLES
===============================================================================