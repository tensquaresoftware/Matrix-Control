# Instructions personnelles pour l'Agent IA Cursor

**Auteur** : Guillaume DUPONT  
**Organisation** : Ten Square Software  
**Contexte** : D√©veloppement de plugins VST/AU avec JUCE  
**Version** : 2.0.0  
**Date de mise √† jour** : 2026-01-30

---

## 1. Communication

### 1.1 Interactions avec moi

- Je m'appelle Guillaume, tu peux m'appeler par mon pr√©nom
- Utilise toujours le tutoiement dans tous nos √©changes
- R√©ponds-moi exclusivement en fran√ßais dans nos conversations
- Sois franc, honn√™te et factuel, m√™me si cela implique de me contredire
- Priorit√© absolue : m'aider √† trouver la solution la plus pertinente !

### 1.2 Structure des r√©ponses

- Structure claire et didactique
- Objectif : m'aider √† progresser
- Garantir p√©rennit√© et maintenabilit√© du code g√©n√©r√©
- Solutions optimales et conformes aux standards professionnels
- **NE PAS** pr√©senter de blocs de code dans le chat lors de modifications/g√©n√©ration
- Privil√©gier les r√©sum√©s et conclusions en langage naturel uniquement
- Le code est d√©j√† visible dans l'√©diteur Cursor, inutile de le r√©p√©ter dans le chat

---

## 2. Process & Workflow

> ‚ö†Ô∏è **OBLIGATOIRE AVANT TOUT CODING**

### 2.1 Workflow en 3 phases

**STOP !** Toujours suivre ce workflow rigoureux :

#### Phase 1 : DESIGN (obligatoire avant de toucher au code)

- Identifier les responsabilit√©s (Single Responsibility Principle)
- D√©tecter la duplication potentielle (Don't Repeat Yourself)
- Choisir les abstractions appropri√©es (interfaces, classes de base)
- Planifier les classes/fonctions avec leurs noms explicites
- Estimer la taille des m√©thodes (objectif : < 15 lignes)
- Me poser la question : "Uncle Bob serait-il fier de ce design ?"
- Dessiner mentalement l'architecture (d√©pendances, hi√©rarchie)

#### Phase 2 : IMPLEMENTATION

- √âcrire le code en suivant strictement le design de la Phase 1
- Respecter les limites quantifiables (voir section d√©di√©e ci-dessous)
- Si une m√©thode d√©passe 15 lignes ‚Üí **STOP** et extraire des helpers IMM√âDIATEMENT
- Si je d√©tecte de la duplication (m√™me 3 lignes) ‚Üí **STOP** et factoriser IMM√âDIATEMENT
- Si une classe d√©passe 200 lignes ‚Üí **STOP** et r√©√©valuer le design (SRP probablement viol√©)
- Nommer chaque fonction pour r√©v√©ler son intention (pas de `doStuff()` ou `process()` vagues)

#### Phase 3 : AUTO-REVIEW (avant de pr√©senter le code √† Guillaume)

- Relire avec un ≈ìil critique "Uncle Bob"
- V√©rifier SOLID pour chaque classe (checklist compl√®te ci-dessous)
- V√©rifier que chaque fonction fait UNE SEULE chose
- V√©rifier qu'il n'y a AUCUNE duplication
- V√©rifier les noms : sont-ils tous explicites et r√©v√®lent-ils l'intention ?
- Si la review √©choue ‚Üí retour Phase 1 (ne pas pr√©senter du code non-Clean)

### 2.2 Exception : Prototypage rapide

Si Guillaume demande explicitement un "prototype rapide", "POC", ou "spike", je peux sauter la Phase 1 mais je DOIS proposer un refactoring Clean apr√®s validation.

---

## 3. Limites Quantifiables

> üö´ **R√®gles strictes, non n√©gociables**

### 3.1 M√©triques de code - Limites MAXIMALES

Ces limites sont des **HARD LIMITS**, pas des suggestions :

#### Fonction/M√©thode : 15 lignes MAXIMUM (id√©al : 5-10)

- **Exception** : m√©thode `show()` ou orchestration peut aller √† 20 lignes SI elle d√©l√®gue proprement
- **Au-del√†** : extraire imm√©diatement en helpers avec noms explicites

#### Classe : 200 lignes MAXIMUM (id√©al : < 150)

- **Si d√©pass√©** : violation probable du SRP ‚Üí s√©parer en plusieurs classes

#### Param√®tres de fonction : 3 MAXIMUM

- **Si > 3** : cr√©er un struct/classe de param√®tres avec noms explicites

#### Complexit√© cyclomatique : < 5 par fonction (id√©al : 1-3)

- **Trop de `if`/`switch`** ‚Üí extraire en fonctions s√©par√©es ou utiliser polymorphisme

#### Niveaux d'indentation : 2 MAXIMUM

- Pas de `if` imbriqu√©s dans des `for` imbriqu√©s dans des `if`
- **Solution** : early returns, extraction de fonctions, guard clauses

#### Duplication de code : 0 tol√©rance absolue

- M√™me 3 lignes similaires = extraction obligatoire en fonction commune
- Utiliser des helpers, des templates, ou des fonctions utilitaires

### 3.2 Proc√©dure quand je d√©passe une limite

1. **NE PAS** continuer √† √©crire du code
2. **STOP** imm√©diatement
3. Me demander : "Pourquoi cette limite est d√©pass√©e ?"
4. R√©pondre honn√™tement : "Parce que cette fonction/classe fait plusieurs choses"
5. Appliquer SRP : extraire les responsabilit√©s en nouvelles fonctions/classes
6. Recommencer avec le bon design

### 3.3 Signaux d'alarme - Indicateurs de mauvais design

- Je me dis "cette fonction est un peu longue mais √ßa va" ‚Üí ‚ùå **NON**, refactoriser
- Je vois du code similaire ailleurs ‚Üí ‚ùå **NON**, factoriser imm√©diatement
- Je ne trouve pas de bon nom pour la fonction ‚Üí Signe qu'elle fait trop de choses
- J'ai besoin d'un commentaire pour expliquer ‚Üí Le code n'est pas assez clair, renommer/refactoriser
- Je mets un commentaire comme "// Partie 1", "// Partie 2" ‚Üí Chaque partie = fonction s√©par√©e

---

## 4. Auto-Critique

> ‚úÖ **Checklist obligatoire avant de pr√©senter du code**

Avant de pr√©senter du code √† Guillaume, je DOIS v√©rifier syst√©matiquement :

### 4.1 SOLID Check ‚úì

- [ ] **S**ingle Responsibility : Chaque classe a UNE SEULE responsabilit√© bien d√©finie ?
  - Tester : puis-je d√©crire la classe en une phrase simple sans "et" ?
- [ ] **O**pen/Closed : Le code est extensible sans modification des classes existantes ?
  - Utilisation d'abstractions, interfaces, polymorphisme ?
- [ ] **L**iskov Substitution : Les sous-classes sont substituables sans casser le comportement ?
  - Les d√©riv√©es respectent les contrats de la classe de base ?
- [ ] **I**nterface Segregation : Pas d'interfaces "fat" for√ßant √† impl√©menter des m√©thodes inutiles ?
  - Interfaces petites et cibl√©es ?
- [ ] **D**ependency Inversion : D√©pendances vers abstractions, pas impl√©mentations concr√®tes ?
  - Les modules de haut niveau ne d√©pendent pas des d√©tails bas niveau ?

### 4.2 Clean Code Check ‚úì

- [ ] Toutes les fonctions < 15 lignes ? (id√©alement < 10)
  - Si NON : extraire imm√©diatement
- [ ] Tous les noms sont explicites et r√©v√®lent l'intention ?
  - `calculateTotalPrice()` pas `calc()`, `isUserLoggedIn()` pas `check()`
- [ ] Aucune duplication de code (m√™me pas 3 lignes similaires) ?
  - Si NON : factoriser en fonction commune
- [ ] Un seul niveau d'abstraction par fonction ?
  - Pas de m√©lange appels haut niveau + manipulations bas niveau
- [ ] Pas de commentaires explicatifs n√©cessaires ?
  - Le code doit √™tre auto-documentant via les noms
- [ ] Pas de magic numbers ?
  - Toutes les constantes sont nomm√©es : `kMaxRetries` pas `3`
- [ ] Pas de code mort ou comment√© ?
  - Supprimer, le versionning (git) garde l'historique

### 4.3 Architecture & Design Check ‚úì

- [ ] Les d√©pendances vont dans le bon sens ?
  - GUI ‚Üí Core, jamais Core ‚Üí GUI
  - Modules de haut niveau ‚Üí abstractions ‚Üê modules bas niveau
- [ ] Pas de couplage fort entre modules ?
  - Utilisation d'interfaces pour d√©coupler
- [ ] Les responsabilit√©s sont clairement s√©par√©es ?
  - Rendering, logique m√©tier, √©tat, coordination : chacun sa classe
- [ ] Facilement testable ?
  - Pas de d√©pendances cach√©es, injection de d√©pendances

### 4.4 Lisibilit√© Check ‚úì

- [ ] Un d√©veloppeur qui d√©couvre le code peut le comprendre sans explication ?
- [ ] Les classes et fonctions ont des noms qui documentent leur r√¥le ?
- [ ] La structure est logique et pr√©visible ?
- [ ] Il n'y a pas de "surprises" ou effets de bord cach√©s ?

### 4.5 R√®gle d'or

> ‚ùå **Si UN SEUL ‚úó ‚Üí Je ne pr√©sente PAS le code**
>
> - Je refactorise d'abord jusqu'√† ce que TOUS les ‚úì soient valid√©s
> - Ensuite seulement je pr√©sente le r√©sultat √† Guillaume

---

## 5. Environnement de D√©veloppement

### 5.1 Syst√®me & Outils

- **Plateforme** : MacBook Pro M5 avec macOS Tahoe
- **IDE** : Cursor (avec abonnement mensuel Agent IA)
- **Compilateur** : Xcode 26
- **Build system** : CMake
- **Framework audio** : JUCE 8.0.12

### 5.2 R√©f√©rence JUCE

- **Installation JUCE** : `/Applications/JUCE`
- **Documentation officielle** : https://docs.juce.com
- **Modules** : `/Applications/JUCE/modules/`
- **CMake** : `/Applications/JUCE/CMake/`

### 5.3 V√©rification du code g√©n√©r√©

- R√©f√®re-toi syst√©matiquement √† la documentation JUCE la plus √† jour
- V√©rifie que chaque API, classe et m√©thode existe dans JUCE 8
- √âvite toute syntaxe obsol√®te (JUCE 7, JUCE 6, etc.)
- Signale explicitement si tu n'es pas certain d'une API

---

## 6. Standards C++ & Qualit√©

### 6.1 G√©n√©ralit√©s C++

- **Standard** : C++17 minimum, compatible Xcode 26
- **Langage du code source** : Anglais uniquement
  - Noms de variables, fonctions, classes
  - Tous les commentaires de code
  - Pas d'accents, pas de fran√ßais dans le code

### 6.2 Git

#### Commits

- Git Commits : Summary/Description en anglais uniquement

#### Tags annot√©s

Lors de la cr√©ation d'un tag Git annot√©, utiliser le format suivant :

- Une phrase de description principale (titre du tag)
- Une petite liste √† puces des points les plus importants qui ont √©t√© retravaill√©s dans le code

**Exemple :**

```
Refactor Slider class and improve focus management

- Refactor Slider: simplify drawing code by removing unnecessary constants and helper methods
- Use reduced() for bounds calculations directly in paint() method
- Improve focus management: add ability to remove focus by clicking on background
```

- Ne pas inclure les d√©tails d'impl√©mentation ni les widgets de test temporaires
- Se concentrer sur les am√©liorations architecturales et les changements significatifs du code

### 6.3 Conventions de nommage

#### Variables & M√©thodes : lowerCamelCase

- Exemples : `audioBuffer`, `processMidiEvents()`, `getSampleRate()`

#### Variables et constantes publiques

- Pas de pr√©fixe ni suffixe
- Exemples : `pluginFactory`, `kMaxBufferSize`

#### Variables et constantes priv√©es

- Suffixe underscore (Google Style)
- Exemples : `apvts_`, `kWidth_`

#### Classes : PascalCase

- Exemples : `PluginProcessor`, `PluginEditor`, `AudioAnalyzer`

#### Enums

- PascalCase pour le type, pr√©fixe `k` pour les valeurs
- Exemples : `enum class ParameterType { kDco, kEnv, kLfo };`

#### Namespaces : PascalCase

- Exemples : `namespace Core { }`, `namespace GUI { }`

#### R√®gle g√©n√©rale

- √âviter les `underscore_case`, sauf cas tr√®s particulier

### 6.4 Magic Numbers - INTERDITS

- **Ne JAMAIS** utiliser de magic numbers dans le code !
- Toujours d√©finir des constantes explicites avec des noms significatifs

#### Exemples √† √©viter

- ‚ùå `if (value == -1)` ‚Üí ‚úÖ `if (value == kNoSysExId)`
- ‚ùå `for (int i = 0; i < 10; ++i)` ‚Üí ‚úÖ `for (int i = 0; i < kModulationBusCount; ++i)`
- ‚úÖ `return nullptr;` ‚Üí OK (nullptr est explicite, pas un magic number)

#### Exceptions acceptables

- Valeurs litt√©rales √©videntes et auto-explicatives : `0`, `1`, `nullptr`, `true`, `false`
- Valeurs dans des tests unitaires o√π la valeur exacte est le sujet du test

### 6.5 Organisation des includes

1. Headers syst√®me C++ (ex : `<vector>`, `<memory>`, etc. puis sauter une ligne)
2. Headers JUCE (ex : `<juce_core/juce_core.h>`, etc. puis sauter une ligne)
3. Headers du projet (ex : `"Core/PatchModel.h"`, etc.)

### 6.6 Chemins des includes

- Utiliser des chemins relatifs √† partir de la racine du projet (configur√© dans CMake)
- **Ne JAMAIS** utiliser de chemins relatifs avec `../` multiples
- **Format** : `"GUI/Panels/MainComponent.h"` plut√¥t que `"../../../../../GUI/Panels/MainComponent.h"`
- Les chemins doivent √™tre clairs, lisibles et maintenables
- ‚úÖ Exemple correct : `#include "GUI/Widgets/Slider.h"`
- ‚ùå Exemple √† √©viter : `#include "../../../GUI/Widgets/Slider.h"`

### 6.7 Include Guards

- Toujours utiliser `#pragma once` en premi√®re ligne de chaque header
- Ne pas utiliser les anciens include guards (`#ifndef`/`#define`/`#endif`)
- Exemple : `#pragma once` en premi√®re ligne, avant tout autre code

### 6.8 Forward Declarations

- Utiliser des forward declarations dans les headers pour r√©duire les d√©pendances
- Inclure les headers complets uniquement dans les `.cpp` quand possible
- Exemple : `class MidiManager;` dans le header, puis `#include "MidiManager.h"` dans le `.cpp`

### 6.9 S√©paration .h/.cpp

Toujours s√©parer d√©claration (`.h`) et d√©finition (`.cpp`) **sauf pour** :

- Templates (d√©finitions dans le header)
- Fonctions inline explicites (marqu√©es `inline`)
- Petites fonctions triviales (getters/setters simples)

Pr√©f√©rer les m√©thodes inline dans le header uniquement si elles sont courtes (< 5 lignes)

- ‚úÖ Exemple inline : `int getValue() const { return value_; }` dans le header
- ‚úÖ Exemple s√©par√© : d√©claration dans `.h`, d√©finition compl√®te dans `.cpp`

### 6.10 Organisation des classes

- Regrouper les membres et m√©thodes logiquement dans les `.h` (ex: paires getter/setter)
- Variables membres (presque toujours priv√©es) apr√®s les m√©thodes publiques/prot√©g√©es
- M√©thodes priv√©es √† la fin, apr√®s les variables membres
- Utiliser `JUCE_DECLARE_NON_COPYABLE` si la classe n'est pas copiable (dernier √©l√©ment)
- Marquer `explicit` les constructeurs √† un seul param√®tre
- Dans les `.cpp`, regrouper les m√©thodes logiquement (appel√©es proches de leurs appelantes)
- Destructeurs virtuels si la classe est destin√©e √† √™tre h√©rit√©e (polymorphisme)
- **R√®gle des 3/5/0** : si on d√©finit destructeur/copy/move, d√©finir ou supprimer les autres explicitement
- Utiliser `= default` pour les constructeurs/destructeurs g√©n√©r√©s par d√©faut (plus explicite)
- Utiliser `= delete` pour d√©sactiver explicitement copy/move/constructeur par d√©faut
- Exemples : `MyClass() = default;` ou `MyClass(const MyClass&) = delete;`

### 6.11 Principes SOLID & Clean Code

> R√©f√©rence : Robert C. Martin / Uncle Bob - Clean Code & Clean Architecture

- Code lisible et compr√©hensible par un humain
- Noms TOUJOURS explicites (pas d'abr√©viations √©nigmatiques)
- Minimiser les commentaires : utiliser uniquement si n√©cessaire
- Refactoriser les blocs > 15 lignes en fonctions courtes aux noms explicites plut√¥t que d'ajouter des commentaires (qui peuvent devenir obsol√®tes)
- Un seul niveau d'abstraction par fonction
- Une seule responsabilit√© (Single Responsibility Principle)
- Pas d'effets cach√©s, pas d'√©tat global modifi√©
- DRY (Don't Repeat Yourself)
- Respecter la Loi de Demeter
- Privil√©gier la d√©l√©gation √† l'h√©ritage
- Exceptions > null pointers
- `std::optional` > null
- Traiter les erreurs au niveau appropri√©

### 6.12 Gestion des Erreurs

- Utiliser les exceptions pour les erreurs exceptionnelles (pas pour le flux normal)
- Utiliser `std::optional` pour les valeurs optionnelles (√©viter `nullptr`)
- Utiliser `std::expected` (C++23) ou des types Result pour les op√©rations pouvant √©chouer
- Ne jamais ignorer silencieusement les erreurs
- Logger les erreurs avec un contexte appropri√©
- Exemple : `std::optional<PatchModel> loadPatch(const juce::File& file);`

### 6.13 RAII (Resource Acquisition Is Initialization)

- Toujours acqu√©rir les ressources dans les constructeurs
- Toujours lib√©rer les ressources dans les destructeurs
- Utiliser les smart pointers pour la gestion automatique de la m√©moire
- Les objets doivent toujours √™tre dans un √©tat valide
- Exemple : `std::unique_ptr<juce::MidiInput> midiInput_;` dans la classe, lib√©r√© automatiquement

### 6.14 Smart Pointers

- Pr√©f√©rer `unique_ptr` pour la propri√©t√© exclusive (ownership)
- Utiliser `shared_ptr` uniquement si n√©cessaire (propri√©t√© partag√©e)
- Utiliser `weak_ptr` pour casser les cycles de r√©f√©rences
- √âviter les pointeurs bruts sauf pour observer (non-owning)
- Exemple : `std::unique_ptr<juce::MidiInput> midiInput_;` pour ownership, `MidiInput* input` pour observer

### 6.15 Move Semantics

- Utiliser `std::move()` pour transf√©rer la propri√©t√© des objets lourds
- Pr√©f√©rer les constructeurs de move et op√©rateurs d'assignation de move
- Marquer `noexcept` quand appropri√© (optimisations, contraintes de move)
- Exemple : `void setData(juce::MemoryBlock&& data) { data_ = std::move(data); }`

---

## 7. Formatage & Style JUCE

### 7.1 Formatage et espacement

#### Indentation

- **Pas de caract√®res de tabulation** ! Utiliser 4 espaces pour l'indentation

#### Style Allman pour les accolades

Accolade ouvrante sur nouvelle ligne :

```cpp
if (x == 0)        // Oui !
{
    foobar();
    return "zero";
}
```

#### Op√©rateurs

- Toujours mettre un espace avant et apr√®s les op√©rateurs binaires : `x = 1 + y - 2 * z / 3;`
- L'op√©rateur `!` ne doit PAS avoir d'espace apr√®s : `if (!foo)` (style JUCE standard)
- L'op√©rateur `~` doit √™tre pr√©c√©d√© d'un espace, mais pas suivi
- Les op√©rateurs `++` et `--` n'ont pas d'espace entre l'op√©rateur et l'op√©rande : `++i`, `--j`

#### Espacement g√©n√©ral

- Jamais d'espace avant une virgule, toujours un espace apr√®s : `foo(x, y);`
- Toujours un espace avant une parenth√®se ouvrante contenant du texte : `foo(123);`
- Jamais d'espace avant une paire de parenth√®ses vides : `foo();`
- Pas d'espace avant un crochet ouvrant utilis√© comme index de tableau : `foo[1]`

#### Lignes vides

- Ligne vide avant `if`, `for`, `while`, `do` quand pr√©c√©d√©s d'une autre instruction
- Ligne vide apr√®s une accolade fermante `}` (sauf si la ligne suivante est juste une autre accolade fermante)

#### Instructions `if`

Ne pas √©crire les `if` sur une seule ligne... **sauf** pour des s√©ries de `if` similaires align√©s verticalement pour montrer un pattern :

```cpp
if (x == 1) return "one";
if (x == 2) return "two";
if (x == 3) return "three";
```

- Oublier les accolades pour des instructions `if` trivialement simples d'une ligne
- Dans un `if-else` avec plusieurs branches, toutes les branches doivent √™tre format√©es de la m√™me mani√®re (toutes avec ou toutes sans accolades)

#### Ne JAMAIS mettre un `else` apr√®s un `return`

```cpp
// ‚úÖ Bon
if (foobar())
    return doSomething();
doSomethingElse();

// ‚ùå Mauvais
if (foobar())
    return doSomething();
else
    doSomethingElse();
```

### 7.2 D√©clarations de pointeurs et r√©f√©rences

- Toujours mettre un espace apr√®s le type, jamais avant : `SomeObject* myObject`, `SomeObject& myObject`
- Ne jamais d√©clarer plusieurs pointeurs/r√©f√©rences du m√™me type dans une seule d√©claration
- Pr√©f√©rer les smart pointers ou typedef pour √©viter les ast√©risques multiples

### 7.3 Modificateur const

- Mettre `const` avant le nom du type : `const Thing& t;` (pas `Thing const& t;`)
- Marquer les m√©thodes qui ne modifient pas l'√©tat comme `const`
- Utiliser `const&` pour les param√®tres en lecture seule
- Pr√©f√©rer `const_iterator` pour les it√©rations en lecture seule
- Les pointeurs const : `const Type*` (pointeur vers constante) vs `Type* const` (pointeur constant)

### 7.4 Op√©rateurs et expressions multi-lignes

Quand on divise une expression contenant des op√©rateurs sur plusieurs lignes, chaque nouvelle ligne doit commencer par l'op√©rateur :

```cpp
auto xyz = foo + bar
            + func(123)
            - def + 4321;
```

M√™me principe pour l'op√©rateur point (m√©thodes cha√Æn√©es) :

```cpp
auto t = AffineTransform::translation(x, y)
                       .scaled(2.0f)
                       .rotated(0.5f);
```

### 7.5 Lambdas

Style pr√©f√©r√© :

```cpp
auto myLambda = [] { return 123; };
auto myLambda = [this, &x](int z) -> float { return x + z; };
auto longerLambda = [](int x, int y) -> int
{
    // ...multiple lines of stuff...
};
```

- Pr√©f√©rer les captures explicites plut√¥t que `[=]` ou `[&]` (plus clair, √©vite captures accidentelles)
- √âviter les captures par valeur de gros objets (pr√©f√©rer `const&` ou `&` selon le cas)
- Exemple : `[this, &x, &y]` plut√¥t que `[&]` si on n'a besoin que de x et y

### 7.6 Valeurs nulles et pointeurs

- **Ne JAMAIS** utiliser `NULL`, `null`, ou `0` pour un pointeur nul ! Toujours utiliser `nullptr`
- Limiter la port√©e des pointeurs possibles nuls :

```cpp
if (auto* f = getFoo())
    f->doSomething();
// f est hors de port√©e ici, impossible d'utiliser un pointeur nul par erreur
```

### 7.7 Passage de param√®tres

- Pour les petits objets POD, toujours passer par valeur, pas par r√©f√©rence
- Utiliser `const Foo&` seulement pour les objets complexes (Array, String, etc.)
- Classes JUCE √† toujours passer par valeur : `Point`, `Time`, `RelativeTime`, `Colour`, `Identifier`, `ModifierKeys`, `JustificationType`, `Range`, `PixelRGB`, `PixelARGB`, `Rectangle`

### 7.8 Op√©rateurs d'incr√©mentation

- Toujours pr√©f√©rer pr√©-incr√©mentation √† post-incr√©mentation : `for (int i = 0; i < 10; ++i)`

### 7.9 Biblioth√®que standard

- Toujours pr√©f√©rer les versions std des fonctions plut√¥t que les √©quivalents C anciens
- Utiliser `std::abs`, `std::sqrt`, `std::sin`, `std::cos`, `std::pow` plut√¥t que `fabs`, `sqrtf`, `powf`, etc.

### 7.10 Types

- Ne jamais utiliser `unsigned` seul - toujours √©crire `unsigned int`
- Utiliser les types JUCE : `int8`, `uint8`, `int16`, `uint16`, `int32`, `uint32`, `int64`, `uint64`
- Pr√©f√©rer les boucles range-based-for pour it√©rer sur les conteneurs plut√¥t que les boucles for brutes

### 7.11 Auto

Style "almost-always-auto" mais √©viter dans certains cas :

- ‚ùå `auto x = 0;` ‚Üí pas OK (pas √©vident que c'est un int sign√©)
- ‚úÖ `for (int i = 0; i < someNumber; ++i)` ‚Üí OK (clair que c'est un int sign√©)
- ‚úÖ `bool someCondition = false;` ‚Üí OK (plus clair que auto)
- ‚úÖ `auto someResult = thisReturnsABool();` ‚Üí OK (utiliser auto si le RHS est une expression)

### 7.12 Commentaires

- Pour les commentaires courts d'une ou deux lignes, pr√©f√©rer `//` plut√¥t que `/* */`
- Toujours laisser un espace avant le texte dans un commentaire `//` : `// oui !` pas `//non !`
- Les noms de code doivent √™tre auto-documentants (√©viter les commentaires)
- Utiliser des commentaires uniquement pour expliquer le "pourquoi", pas le "comment"
- Pour les APIs publiques complexes, consid√©rer Doxygen/Javadoc style comments

### 7.13 Macros

- **Ne pas utiliser de macros** ! Traiter les macros comme un dernier recours
- Ne jamais utiliser une macro juste pour contenir une valeur constante ou pour effectuer une fonction qui pourrait √™tre faite comme une vraie fonction inline
- Si des macros sont utilis√©es, leur donner des noms qui ne vont pas entrer en conflit avec d'autres codes
- `#undef` les macros apr√®s les avoir utilis√©es, si possible

### 7.14 Templates

- Les param√®tres de template doivent suivre leur type sans espace : `vector<int>`
- Dans une d√©claration template, laisser un espace avant le crochet ouvrant : `template <typename Type1, typename Type2>`

### 7.15 D√©pendances

- √âviter les d√©pendances circulaires entre modules
- Utiliser des interfaces abstraites pour d√©coupler (Dependency Inversion Principle)
- Respecter la hi√©rarchie des d√©pendances (GUI d√©pend de Core, pas l'inverse)

### 7.16 Enums

- Pr√©f√©rer `enum class` √† `enum` pour la s√©curit√© de type et √©viter les collisions
- Nommer les enums au singulier (sauf collections) : `enum class ParameterType { kDco, kEnv, kLfo };`
- Pr√©fixer les valeurs avec `k` : `ParameterType::kDco`
- Exemple : `enum class ClipboardType { kEmpty, kDco, kEnv, kLfo, kPatch };`

### 7.17 Initialisation

- Pr√©f√©rer l'initialisation uniforme `{}` : `int value {0};` plut√¥t que `int value = 0;`
- Initialiser les membres dans la liste d'initialisation du constructeur
- Ordre d'initialisation = ordre de d√©claration des membres (pas l'ordre de la liste)
- Exemple : `MyClass(int x) : member1_ {x}, member2_ {0} {}`

### 7.18 Namespaces

- Utiliser des namespaces pour organiser le code par module
- √âviter les `using namespace` dans les headers (pollution globale)
- OK dans les `.cpp` pour simplifier : `using juce::String;`
- Exemple : `namespace Core { class MidiManager; }`

### 7.19 Static Members

- Pr√©f√©rer les fonctions libres statiques aux m√©thodes statiques quand possible
- Utiliser `static constexpr` pour les constantes de classe
- Exemple : `static constexpr int kMaxBufferSize {1024};`

### 7.20 Constexpr

- Utiliser `constexpr` pour les fonctions calculables √† la compilation
- Utiliser `constexpr` pour les variables constantes calculables √† la compilation
- Pr√©f√©rer `constexpr` √† `const` pour les constantes calculables √† la compilation
- `constexpr` implique `const`, mais permet l'√©valuation √† la compilation
- Exemples :

```cpp
constexpr int calculateSize(int count) { return count * 4; }
constexpr int kBufferSize {calculateSize(256)};
```

### 7.21 Virtual Functions

- Utiliser `override` explicitement (pas `virtual` dans les classes d√©riv√©es)
- Utiliser `final` pour emp√™cher la d√©rivation suppl√©mentaire si appropri√©
- Pr√©f√©rer la composition √† l'h√©ritage (SOLID : favoriser la d√©l√©gation)
- Exemple : `void paint(Graphics& g) override;`

### 7.22 Assertions

- Utiliser `jassert` (JUCE) ou `assert` pour les invariants de d√©veloppement
- Ne pas utiliser d'assertions pour la gestion d'erreurs utilisateur (utiliser exceptions)
- Les assertions peuvent √™tre d√©sactiv√©es en release : ne pas y mettre de logique critique
- Exemple : `jassert(bufferSize > 0);` pour v√©rifier une pr√©condition

### 7.23 Logging

- Utiliser `juce::Logger` pour le logging structur√©
- Niveaux appropri√©s : `DBG()`, `Logger::writeToLog()` pour debug, erreurs critiques
- √âviter le logging excessif dans les boucles critiques
- Logger avec contexte : inclure informations pertinentes (fichier, ligne, valeurs)

---

## 8. R√®gles Sp√©cifiques JUCE

### 8.1 Nommage des classes du plugin

- **Classe du processeur** : `PluginProcessor` (fichiers : `PluginProcessor.h`/`.cpp`)
- **Classe de l'√©diteur UI** : `PluginEditor` (fichiers : `PluginEditor.h`/`.cpp`)

### 8.2 APIs JUCE d√©pr√©ci√©es - √Ä √âVITER

- ~~`getCurrentPlaybackSampleRate()`~~ ‚Üí `getSampleRate()`
- ~~`setPlayConfigDetails()`~~ ‚Üí `setBusesLayout()`
- ~~`Timer` avec callbacks~~ ‚Üí `juce::HighResolutionTimer`
- ~~`AudioProcessorValueTreeState`~~ ‚Üí `ValueTree` moderne
- ~~Legacy parameter handling~~ ‚Üí `juce::AudioProcessorParameter`

> La liste est non exhaustive, prendre le temps de la compl√©ter le cas √©ch√©ant.

### 8.3 Thread-Safety

- Toujours consid√©rer la thread-safety dans le code audio (`processBlock()` appel√© depuis le thread audio)
- Utiliser `juce::MessageManager::callAsync()` pour appeler le thread GUI depuis d'autres threads
- Utiliser `juce::AbstractFifo` ou `juce::LockFreeFifo` pour la communication inter-threads (lock-free)
- Les listeners APVTS sont thread-safe, mais les mises √† jour GUI doivent se faire depuis le thread message
- **Ne JAMAIS** appeler de m√©thodes GUI depuis le thread audio
- Exemple : `juce::MessageManager::callAsync([this] { updateGUI(); });` depuis le thread audio

### 8.4 Performance

- √âviter les allocations m√©moire dans `processBlock()` (thread audio)
- Utiliser des buffers pr√©-allou√©s
- √âviter les appels syst√®me dans les boucles critiques
- Profiler avant d'optimiser
- Pr√©f√©rer les algorithmes in-place quand possible
- √âviter les copies inutiles : utiliser `const&` ou move semantics

### 8.5 Tests Unitaires

- √âcrire des tests pour les classes m√©tier (pas pour les composants GUI)
- Utiliser un framework de test (ex: Catch2, Google Test)
- Un test = une responsabilit√©, nom explicite
- Tests isol√©s, pas de d√©pendances entre tests
- Exemple : `TEST_CASE("SysExParser validates checksum correctly")`

### 8.6 Complexit√©

- Maintenir la complexit√© cyclomatique < 5 par fonction (id√©al : 1-3)
- Si trop complexe, refactoriser en sous-fonctions
- √âviter > 3 param√®tres : consid√©rer un struct/class de param√®tres
- Pr√©f√©rer les early returns pour r√©duire l'imbrication

---

**Fin des instructions personnelles**
